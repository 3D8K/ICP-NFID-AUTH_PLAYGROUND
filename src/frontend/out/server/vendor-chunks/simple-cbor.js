"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/simple-cbor";
exports.ids = ["vendor-chunks/simple-cbor"];
exports.modules = {

/***/ "(ssr)/../../node_modules/simple-cbor/src/index.js":
/*!***************************************************!*\
  !*** ../../node_modules/simple-cbor/src/index.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__export(__webpack_require__(/*! ./serializer */ \"(ssr)/../../node_modules/simple-cbor/src/serializer.js\"));\nconst value = __importStar(__webpack_require__(/*! ./value */ \"(ssr)/../../node_modules/simple-cbor/src/value.js\"));\nexports.value = value;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL3NpbXBsZS1jYm9yL3NyYy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELFNBQVMsbUJBQU8sQ0FBQyw0RUFBYztBQUMvQiwyQkFBMkIsbUJBQU8sQ0FBQyxrRUFBUztBQUM1QyxhQUFhO0FBQ2IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvc2ltcGxlLWNib3Ivc3JjL2luZGV4LmpzPzY3OWQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBfX2V4cG9ydChtKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xufVxudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcbiAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnQocmVxdWlyZShcIi4vc2VyaWFsaXplclwiKSk7XG5jb25zdCB2YWx1ZSA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi92YWx1ZVwiKSk7XG5leHBvcnRzLnZhbHVlID0gdmFsdWU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/simple-cbor/src/index.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/simple-cbor/src/serializer.js":
/*!********************************************************!*\
  !*** ../../node_modules/simple-cbor/src/serializer.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst cbor = __importStar(__webpack_require__(/*! ./value */ \"(ssr)/../../node_modules/simple-cbor/src/value.js\"));\nconst BufferClasses = [\n    ArrayBuffer,\n    Uint8Array,\n    Uint16Array,\n    Uint32Array,\n    Int8Array,\n    Int16Array,\n    Int32Array,\n    Float32Array,\n    Float64Array,\n];\nclass JsonDefaultCborEncoder {\n    // @param _serializer The CBOR Serializer to use.\n    // @param _stable Whether or not keys from objects should be sorted (stable). This is\n    //     particularly useful when testing encodings between JSON objects.\n    constructor(_serializer, _stable = false) {\n        this._serializer = _serializer;\n        this._stable = _stable;\n        this.name = \"jsonDefault\";\n        this.priority = -100;\n    }\n    match(value) {\n        return [\"undefined\", \"boolean\", \"number\", \"string\", \"object\"].indexOf(typeof value) != -1;\n    }\n    encode(value) {\n        switch (typeof value) {\n            case \"undefined\":\n                return cbor.undefined_();\n            case \"boolean\":\n                return cbor.bool(value);\n            case \"number\":\n                if (Math.floor(value) === value) {\n                    return cbor.number(value);\n                }\n                else {\n                    return cbor.doubleFloat(value);\n                }\n            case \"string\":\n                return cbor.string(value);\n            case \"object\":\n                if (value === null) {\n                    return cbor.null_();\n                }\n                else if (Array.isArray(value)) {\n                    return cbor.array(value.map((x) => this._serializer.serializeValue(x)));\n                }\n                else if (BufferClasses.find((x) => value instanceof x)) {\n                    return cbor.bytes(value.buffer);\n                }\n                else if (Object.getOwnPropertyNames(value).indexOf(\"toJSON\") !== -1) {\n                    return this.encode(value.toJSON());\n                }\n                else if (value instanceof Map) {\n                    const m = new Map();\n                    for (const [key, item] of value.entries()) {\n                        m.set(key, this._serializer.serializeValue(item));\n                    }\n                    return cbor.map(m, this._stable);\n                }\n                else {\n                    const m = new Map();\n                    for (const [key, item] of Object.entries(value)) {\n                        m.set(key, this._serializer.serializeValue(item));\n                    }\n                    return cbor.map(m, this._stable);\n                }\n            default:\n                throw new Error(\"Invalid value.\");\n        }\n    }\n}\nexports.JsonDefaultCborEncoder = JsonDefaultCborEncoder;\nclass ToCborEncoder {\n    constructor() {\n        this.name = \"cborEncoder\";\n        this.priority = -90;\n    }\n    match(value) {\n        return typeof value == \"object\" && typeof value[\"toCBOR\"] == \"function\";\n    }\n    encode(value) {\n        return value.toCBOR();\n    }\n}\nexports.ToCborEncoder = ToCborEncoder;\nclass CborSerializer {\n    constructor() {\n        this._encoders = new Set();\n    }\n    static withDefaultEncoders(stable = false) {\n        const s = new this();\n        s.addEncoder(new JsonDefaultCborEncoder(s, stable));\n        s.addEncoder(new ToCborEncoder());\n        return s;\n    }\n    removeEncoder(name) {\n        // Has to make an extra call to values() to ensure it doesn't break on iteration.\n        for (const encoder of this._encoders.values()) {\n            if (encoder.name == name) {\n                this._encoders.delete(encoder);\n            }\n        }\n    }\n    addEncoder(encoder) {\n        this._encoders.add(encoder);\n    }\n    getEncoderFor(value) {\n        let chosenEncoder = null;\n        for (const encoder of this._encoders) {\n            if (!chosenEncoder || encoder.priority > chosenEncoder.priority) {\n                if (encoder.match(value)) {\n                    chosenEncoder = encoder;\n                }\n            }\n        }\n        if (chosenEncoder === null) {\n            throw new Error(\"Could not find an encoder for value.\");\n        }\n        return chosenEncoder;\n    }\n    serializeValue(value) {\n        return this.getEncoderFor(value).encode(value);\n    }\n    serialize(value) {\n        return this.serializeValue(value);\n    }\n}\nexports.CborSerializer = CborSerializer;\nclass SelfDescribeCborSerializer extends CborSerializer {\n    serialize(value) {\n        return cbor.raw(new Uint8Array([\n            // Self describe CBOR.\n            ...new Uint8Array([0xd9, 0xd9, 0xf7]),\n            ...new Uint8Array(super.serializeValue(value)),\n        ]));\n    }\n}\nexports.SelfDescribeCborSerializer = SelfDescribeCborSerializer;\n//# sourceMappingURL=serializer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL3NpbXBsZS1jYm9yL3NyYy9zZXJpYWxpemVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMEJBQTBCLG1CQUFPLENBQUMsa0VBQVM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQyIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9zaW1wbGUtY2Jvci9zcmMvc2VyaWFsaXplci5qcz9iNTk1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcbiAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY2JvciA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi92YWx1ZVwiKSk7XG5jb25zdCBCdWZmZXJDbGFzc2VzID0gW1xuICAgIEFycmF5QnVmZmVyLFxuICAgIFVpbnQ4QXJyYXksXG4gICAgVWludDE2QXJyYXksXG4gICAgVWludDMyQXJyYXksXG4gICAgSW50OEFycmF5LFxuICAgIEludDE2QXJyYXksXG4gICAgSW50MzJBcnJheSxcbiAgICBGbG9hdDMyQXJyYXksXG4gICAgRmxvYXQ2NEFycmF5LFxuXTtcbmNsYXNzIEpzb25EZWZhdWx0Q2JvckVuY29kZXIge1xuICAgIC8vIEBwYXJhbSBfc2VyaWFsaXplciBUaGUgQ0JPUiBTZXJpYWxpemVyIHRvIHVzZS5cbiAgICAvLyBAcGFyYW0gX3N0YWJsZSBXaGV0aGVyIG9yIG5vdCBrZXlzIGZyb20gb2JqZWN0cyBzaG91bGQgYmUgc29ydGVkIChzdGFibGUpLiBUaGlzIGlzXG4gICAgLy8gICAgIHBhcnRpY3VsYXJseSB1c2VmdWwgd2hlbiB0ZXN0aW5nIGVuY29kaW5ncyBiZXR3ZWVuIEpTT04gb2JqZWN0cy5cbiAgICBjb25zdHJ1Y3Rvcihfc2VyaWFsaXplciwgX3N0YWJsZSA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuX3NlcmlhbGl6ZXIgPSBfc2VyaWFsaXplcjtcbiAgICAgICAgdGhpcy5fc3RhYmxlID0gX3N0YWJsZTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJqc29uRGVmYXVsdFwiO1xuICAgICAgICB0aGlzLnByaW9yaXR5ID0gLTEwMDtcbiAgICB9XG4gICAgbWF0Y2godmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIFtcInVuZGVmaW5lZFwiLCBcImJvb2xlYW5cIiwgXCJudW1iZXJcIiwgXCJzdHJpbmdcIiwgXCJvYmplY3RcIl0uaW5kZXhPZih0eXBlb2YgdmFsdWUpICE9IC0xO1xuICAgIH1cbiAgICBlbmNvZGUodmFsdWUpIHtcbiAgICAgICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ1bmRlZmluZWRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gY2Jvci51bmRlZmluZWRfKCk7XG4gICAgICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBjYm9yLmJvb2wodmFsdWUpO1xuICAgICAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgICAgIGlmIChNYXRoLmZsb29yKHZhbHVlKSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNib3IubnVtYmVyKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYm9yLmRvdWJsZUZsb2F0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNib3Iuc3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNib3IubnVsbF8oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNib3IuYXJyYXkodmFsdWUubWFwKCh4KSA9PiB0aGlzLl9zZXJpYWxpemVyLnNlcmlhbGl6ZVZhbHVlKHgpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKEJ1ZmZlckNsYXNzZXMuZmluZCgoeCkgPT4gdmFsdWUgaW5zdGFuY2VvZiB4KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2Jvci5ieXRlcyh2YWx1ZS5idWZmZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSkuaW5kZXhPZihcInRvSlNPTlwiKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKHZhbHVlLnRvSlNPTigpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbSA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCBpdGVtXSBvZiB2YWx1ZS5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG0uc2V0KGtleSwgdGhpcy5fc2VyaWFsaXplci5zZXJpYWxpemVWYWx1ZShpdGVtKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNib3IubWFwKG0sIHRoaXMuX3N0YWJsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIGl0ZW1dIG9mIE9iamVjdC5lbnRyaWVzKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbS5zZXQoa2V5LCB0aGlzLl9zZXJpYWxpemVyLnNlcmlhbGl6ZVZhbHVlKGl0ZW0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2Jvci5tYXAobSwgdGhpcy5fc3RhYmxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdmFsdWUuXCIpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5Kc29uRGVmYXVsdENib3JFbmNvZGVyID0gSnNvbkRlZmF1bHRDYm9yRW5jb2RlcjtcbmNsYXNzIFRvQ2JvckVuY29kZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLm5hbWUgPSBcImNib3JFbmNvZGVyXCI7XG4gICAgICAgIHRoaXMucHJpb3JpdHkgPSAtOTA7XG4gICAgfVxuICAgIG1hdGNoKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgdmFsdWVbXCJ0b0NCT1JcIl0gPT0gXCJmdW5jdGlvblwiO1xuICAgIH1cbiAgICBlbmNvZGUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnRvQ0JPUigpO1xuICAgIH1cbn1cbmV4cG9ydHMuVG9DYm9yRW5jb2RlciA9IFRvQ2JvckVuY29kZXI7XG5jbGFzcyBDYm9yU2VyaWFsaXplciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX2VuY29kZXJzID0gbmV3IFNldCgpO1xuICAgIH1cbiAgICBzdGF0aWMgd2l0aERlZmF1bHRFbmNvZGVycyhzdGFibGUgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCBzID0gbmV3IHRoaXMoKTtcbiAgICAgICAgcy5hZGRFbmNvZGVyKG5ldyBKc29uRGVmYXVsdENib3JFbmNvZGVyKHMsIHN0YWJsZSkpO1xuICAgICAgICBzLmFkZEVuY29kZXIobmV3IFRvQ2JvckVuY29kZXIoKSk7XG4gICAgICAgIHJldHVybiBzO1xuICAgIH1cbiAgICByZW1vdmVFbmNvZGVyKG5hbWUpIHtcbiAgICAgICAgLy8gSGFzIHRvIG1ha2UgYW4gZXh0cmEgY2FsbCB0byB2YWx1ZXMoKSB0byBlbnN1cmUgaXQgZG9lc24ndCBicmVhayBvbiBpdGVyYXRpb24uXG4gICAgICAgIGZvciAoY29uc3QgZW5jb2RlciBvZiB0aGlzLl9lbmNvZGVycy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgaWYgKGVuY29kZXIubmFtZSA9PSBuYW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZW5jb2RlcnMuZGVsZXRlKGVuY29kZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFkZEVuY29kZXIoZW5jb2Rlcikge1xuICAgICAgICB0aGlzLl9lbmNvZGVycy5hZGQoZW5jb2Rlcik7XG4gICAgfVxuICAgIGdldEVuY29kZXJGb3IodmFsdWUpIHtcbiAgICAgICAgbGV0IGNob3NlbkVuY29kZXIgPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IGVuY29kZXIgb2YgdGhpcy5fZW5jb2RlcnMpIHtcbiAgICAgICAgICAgIGlmICghY2hvc2VuRW5jb2RlciB8fCBlbmNvZGVyLnByaW9yaXR5ID4gY2hvc2VuRW5jb2Rlci5wcmlvcml0eSkge1xuICAgICAgICAgICAgICAgIGlmIChlbmNvZGVyLm1hdGNoKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBjaG9zZW5FbmNvZGVyID0gZW5jb2RlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNob3NlbkVuY29kZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIGFuIGVuY29kZXIgZm9yIHZhbHVlLlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hvc2VuRW5jb2RlcjtcbiAgICB9XG4gICAgc2VyaWFsaXplVmFsdWUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RW5jb2RlckZvcih2YWx1ZSkuZW5jb2RlKHZhbHVlKTtcbiAgICB9XG4gICAgc2VyaWFsaXplKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZVZhbHVlKHZhbHVlKTtcbiAgICB9XG59XG5leHBvcnRzLkNib3JTZXJpYWxpemVyID0gQ2JvclNlcmlhbGl6ZXI7XG5jbGFzcyBTZWxmRGVzY3JpYmVDYm9yU2VyaWFsaXplciBleHRlbmRzIENib3JTZXJpYWxpemVyIHtcbiAgICBzZXJpYWxpemUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGNib3IucmF3KG5ldyBVaW50OEFycmF5KFtcbiAgICAgICAgICAgIC8vIFNlbGYgZGVzY3JpYmUgQ0JPUi5cbiAgICAgICAgICAgIC4uLm5ldyBVaW50OEFycmF5KFsweGQ5LCAweGQ5LCAweGY3XSksXG4gICAgICAgICAgICAuLi5uZXcgVWludDhBcnJheShzdXBlci5zZXJpYWxpemVWYWx1ZSh2YWx1ZSkpLFxuICAgICAgICBdKSk7XG4gICAgfVxufVxuZXhwb3J0cy5TZWxmRGVzY3JpYmVDYm9yU2VyaWFsaXplciA9IFNlbGZEZXNjcmliZUNib3JTZXJpYWxpemVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VyaWFsaXplci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/simple-cbor/src/serializer.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/simple-cbor/src/value.js":
/*!***************************************************!*\
  !*** ../../node_modules/simple-cbor/src/value.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst MAX_U64_NUMBER = 0x20000000000000;\nfunction _concat(a, ...args) {\n    const newBuffer = new Uint8Array(a.byteLength + args.reduce((acc, b) => acc + b.byteLength, 0));\n    newBuffer.set(new Uint8Array(a), 0);\n    let i = a.byteLength;\n    for (const b of args) {\n        newBuffer.set(new Uint8Array(b), i);\n        i += b.byteLength;\n    }\n    return newBuffer.buffer;\n}\nfunction _serializeValue(major, minor, value) {\n    // Remove everything that's not an hexadecimal character. These are not\n    // considered errors since the value was already validated and they might\n    // be number decimals or sign.\n    value = value.replace(/[^0-9a-fA-F]/g, \"\");\n    // Create the buffer from the value with left padding with 0.\n    const length = 2 ** (minor - 24 /* Int8 */);\n    value = value.slice(-length * 2).padStart(length * 2, \"0\");\n    const bytes = [(major << 5) + minor].concat(value.match(/../g).map((byte) => parseInt(byte, 16)));\n    return new Uint8Array(bytes).buffer;\n}\nfunction _serializeNumber(major, value) {\n    if (value < 24) {\n        return new Uint8Array([(major << 5) + value]).buffer;\n    }\n    else {\n        const minor = value <= 0xff\n            ? 24 /* Int8 */\n            : value <= 0xffff\n                ? 25 /* Int16 */\n                : value <= 0xffffffff\n                    ? 26 /* Int32 */\n                    : 27 /* Int64 */;\n        return _serializeValue(major, minor, value.toString(16));\n    }\n}\nfunction _serializeString(str) {\n    const utf8 = [];\n    for (let i = 0; i < str.length; i++) {\n        let charcode = str.charCodeAt(i);\n        if (charcode < 0x80) {\n            utf8.push(charcode);\n        }\n        else if (charcode < 0x800) {\n            utf8.push(0xc0 | (charcode >> 6), 0x80 | (charcode & 0x3f));\n        }\n        else if (charcode < 0xd800 || charcode >= 0xe000) {\n            utf8.push(0xe0 | (charcode >> 12), 0x80 | ((charcode >> 6) & 0x3f), 0x80 | (charcode & 0x3f));\n        }\n        else {\n            // Surrogate pair\n            i++;\n            charcode = ((charcode & 0x3ff) << 10) | (str.charCodeAt(i) & 0x3ff);\n            utf8.push(0xf0 | (charcode >> 18), 0x80 | ((charcode >> 12) & 0x3f), 0x80 | ((charcode >> 6) & 0x3f), 0x80 | (charcode & 0x3f));\n        }\n    }\n    return _concat(new Uint8Array(_serializeNumber(3 /* TextString */, str.length)), new Uint8Array(utf8));\n}\n/**\n * Tag a value.\n */\nfunction tagged(tag, value) {\n    if (tag == 0xd9d9f7) {\n        return _concat(new Uint8Array([0xd9, 0xd9, 0xf7]), value);\n    }\n    if (tag < 24) {\n        return _concat(new Uint8Array([(6 /* Tag */ << 5) + tag]), value);\n    }\n    else {\n        const minor = tag <= 0xff\n            ? 24 /* Int8 */\n            : tag <= 0xffff\n                ? 25 /* Int16 */\n                : tag <= 0xffffffff\n                    ? 26 /* Int32 */\n                    : 27 /* Int64 */;\n        const length = 2 ** (minor - 24 /* Int8 */);\n        const value = tag\n            .toString(16)\n            .slice(-length * 2)\n            .padStart(length * 2, \"0\");\n        const bytes = [(6 /* Tag */ << 5) + minor].concat(value.match(/../g).map((byte) => parseInt(byte, 16)));\n        return new Uint8Array(bytes).buffer;\n    }\n}\nexports.tagged = tagged;\n/**\n * Set the raw bytes contained by this value. This should only be used with another\n * CborValue, or if you are implementing extensions to CBOR.\n * @param bytes A buffer containing the value.\n */\nfunction raw(bytes) {\n    return new Uint8Array(bytes).buffer;\n}\nexports.raw = raw;\n/**\n * Encode a number that is between [0, 23].\n * @param n\n */\nfunction uSmall(n) {\n    if (isNaN(n)) {\n        throw new RangeError(\"Invalid number.\");\n    }\n    n = Math.min(Math.max(0, n), 23); // Clamp it.\n    const bytes = [(0 /* UnsignedInteger */ << 5) + n];\n    return new Uint8Array(bytes).buffer;\n}\nexports.uSmall = uSmall;\nfunction u8(u8, radix) {\n    // Force u8 into a number, and validate it.\n    u8 = parseInt(\"\" + u8, radix);\n    if (isNaN(u8)) {\n        throw new RangeError(\"Invalid number.\");\n    }\n    u8 = Math.min(Math.max(0, u8), 0xff); // Clamp it.\n    u8 = u8.toString(16);\n    return _serializeValue(0 /* UnsignedInteger */, 24 /* Int8 */, u8);\n}\nexports.u8 = u8;\nfunction u16(u16, radix) {\n    // Force u16 into a number, and validate it.\n    u16 = parseInt(\"\" + u16, radix);\n    if (isNaN(u16)) {\n        throw new RangeError(\"Invalid number.\");\n    }\n    u16 = Math.min(Math.max(0, u16), 0xffff); // Clamp it.\n    u16 = u16.toString(16);\n    return _serializeValue(0 /* UnsignedInteger */, 25 /* Int16 */, u16);\n}\nexports.u16 = u16;\nfunction u32(u32, radix) {\n    // Force u32 into a number, and validate it.\n    u32 = parseInt(\"\" + u32, radix);\n    if (isNaN(u32)) {\n        throw new RangeError(\"Invalid number.\");\n    }\n    u32 = Math.min(Math.max(0, u32), 0xffffffff); // Clamp it.\n    u32 = u32.toString(16);\n    return _serializeValue(0 /* UnsignedInteger */, 26 /* Int32 */, u32);\n}\nexports.u32 = u32;\nfunction u64(u64, radix) {\n    // Special consideration for numbers that might be larger than expected.\n    if (typeof u64 == \"string\" && radix == 16) {\n        // This is the only case where we guarantee we'll encode the number directly.\n        // Validate it's all hexadecimal first.\n        if (u64.match(/[^0-9a-fA-F]/)) {\n            throw new RangeError(\"Invalid number.\");\n        }\n        return _serializeValue(0 /* UnsignedInteger */, 27 /* Int64 */, u64);\n    }\n    // Force u64 into a number, and validate it.\n    u64 = parseInt(\"\" + u64, radix);\n    if (isNaN(u64)) {\n        throw new RangeError(\"Invalid number.\");\n    }\n    u64 = Math.min(Math.max(0, u64), MAX_U64_NUMBER); // Clamp it to actual limit.\n    u64 = u64.toString(16);\n    return _serializeValue(0 /* UnsignedInteger */, 27 /* Int64 */, u64);\n}\nexports.u64 = u64;\n/**\n * Encode a negative number that is between [-24, -1].\n */\nfunction iSmall(n) {\n    if (isNaN(n)) {\n        throw new RangeError(\"Invalid number.\");\n    }\n    if (n === 0) {\n        return uSmall(0);\n    }\n    // Negative n, clamped to [1, 24], minus 1 (there's no negative 0).\n    n = Math.min(Math.max(0, -n), 24) - 1;\n    const bytes = [(1 /* SignedInteger */ << 5) + n];\n    return new Uint8Array(bytes).buffer;\n}\nexports.iSmall = iSmall;\nfunction i8(i8, radix) {\n    // Force i8 into a number, and validate it.\n    i8 = parseInt(\"\" + i8, radix);\n    if (isNaN(i8)) {\n        throw new RangeError(\"Invalid number.\");\n    }\n    // Negative n, clamped, minus 1 (there's no negative 0).\n    i8 = Math.min(Math.max(0, -i8 - 1), 0xff);\n    i8 = i8.toString(16);\n    return _serializeValue(1 /* SignedInteger */, 24 /* Int8 */, i8);\n}\nexports.i8 = i8;\nfunction i16(i16, radix) {\n    // Force i16 into a number, and validate it.\n    i16 = parseInt(\"\" + i16, radix);\n    if (isNaN(i16)) {\n        throw new RangeError(\"Invalid number.\");\n    }\n    // Negative n, clamped, minus 1 (there's no negative 0).\n    i16 = Math.min(Math.max(0, -i16 - 1), 0xffff);\n    i16 = i16.toString(16);\n    return _serializeValue(1 /* SignedInteger */, 25 /* Int16 */, i16);\n}\nexports.i16 = i16;\nfunction i32(i32, radix) {\n    // Force i32 into a number, and validate it.\n    i32 = parseInt(\"\" + i32, radix);\n    if (isNaN(i32)) {\n        throw new RangeError(\"Invalid number.\");\n    }\n    // Negative n, clamped, minus 1 (there's no negative 0).\n    i32 = Math.min(Math.max(0, -i32 - 1), 0xffffffff);\n    i32 = i32.toString(16);\n    return _serializeValue(1 /* SignedInteger */, 26 /* Int32 */, i32);\n}\nexports.i32 = i32;\nfunction i64(i64, radix) {\n    // Special consideration for numbers that might be larger than expected.\n    if (typeof i64 == \"string\" && radix == 16) {\n        if (i64.startsWith(\"-\")) {\n            i64 = i64.slice(1);\n        }\n        else {\n            // Clamp it.\n            i64 = \"0\";\n        }\n        // This is the only case where we guarantee we'll encode the number directly.\n        // Validate it's all hexadecimal first.\n        if (i64.match(/[^0-9a-fA-F]/) || i64.length > 16) {\n            throw new RangeError(\"Invalid number.\");\n        }\n        // We need to do -1 to the number.\n        let done = false;\n        let newI64 = i64.split(\"\").reduceRight((acc, x) => {\n            if (done) {\n                return x + acc;\n            }\n            let n = parseInt(x, 16) - 1;\n            if (n >= 0) {\n                done = true;\n                return n.toString(16) + acc;\n            }\n            else {\n                return \"f\" + acc;\n            }\n        }, \"\");\n        if (!done) {\n            // This number was 0.\n            return u64(0);\n        }\n        return _serializeValue(1 /* SignedInteger */, 27 /* Int64 */, newI64);\n    }\n    // Force i64 into a number, and validate it.\n    i64 = parseInt(\"\" + i64, radix);\n    if (isNaN(i64)) {\n        throw new RangeError(\"Invalid number.\");\n    }\n    i64 = Math.min(Math.max(0, -i64 - 1), 0x20000000000000); // Clamp it to actual.\n    i64 = i64.toString(16);\n    return _serializeValue(1 /* SignedInteger */, 27 /* Int64 */, i64);\n}\nexports.i64 = i64;\n/**\n * Encode a number using the smallest amount of bytes, by calling the methods\n * above. e.g. If the number fits in a u8, it will use that.\n */\nfunction number(n) {\n    if (n >= 0) {\n        if (n < 24) {\n            return uSmall(n);\n        }\n        else if (n <= 0xff) {\n            return u8(n);\n        }\n        else if (n <= 0xffff) {\n            return u16(n);\n        }\n        else if (n <= 0xffffffff) {\n            return u32(n);\n        }\n        else {\n            return u64(n);\n        }\n    }\n    else {\n        if (n >= -24) {\n            return iSmall(n);\n        }\n        else if (n >= -0xff) {\n            return i8(n);\n        }\n        else if (n >= -0xffff) {\n            return i16(n);\n        }\n        else if (n >= -0xffffffff) {\n            return i32(n);\n        }\n        else {\n            return i64(n);\n        }\n    }\n}\nexports.number = number;\n/**\n * Encode a byte array. This is different than the `raw()` method.\n */\nfunction bytes(bytes) {\n    return _concat(_serializeNumber(2 /* ByteString */, bytes.byteLength), bytes);\n}\nexports.bytes = bytes;\n/**\n * Encode a JavaScript string.\n */\nfunction string(str) {\n    return _serializeString(str);\n}\nexports.string = string;\n/**\n * Encode an array of cbor values.\n */\nfunction array(items) {\n    return _concat(_serializeNumber(4 /* Array */, items.length), ...items);\n}\nexports.array = array;\n/**\n * Encode a map of key-value pairs. The keys are string, and the values are CBOR\n * encoded.\n */\nfunction map(items, stable = false) {\n    if (!(items instanceof Map)) {\n        items = new Map(Object.entries(items));\n    }\n    let entries = Array.from(items.entries());\n    if (stable) {\n        entries = entries.sort(([keyA], [keyB]) => keyA.localeCompare(keyB));\n    }\n    return _concat(_serializeNumber(5 /* Map */, items.size), ...entries.map(([k, v]) => _concat(_serializeString(k), v)));\n}\nexports.map = map;\n/**\n * Encode a single (32 bits) precision floating point number.\n */\nfunction singleFloat(f) {\n    const single = new Float32Array([f]);\n    return _concat(new Uint8Array([(7 /* SimpleValue */ << 5) + 26]), new Uint8Array(single.buffer));\n}\nexports.singleFloat = singleFloat;\n/**\n * Encode a double (64 bits) precision floating point number.\n */\nfunction doubleFloat(f) {\n    const single = new Float64Array([f]);\n    return _concat(new Uint8Array([(7 /* SimpleValue */ << 5) + 27]), new Uint8Array(single.buffer));\n}\nexports.doubleFloat = doubleFloat;\nfunction bool(v) {\n    return v ? true_() : false_();\n}\nexports.bool = bool;\n/**\n * Encode the boolean true.\n */\nfunction true_() {\n    return raw(new Uint8Array([(7 /* SimpleValue */ << 5) + 21]));\n}\nexports.true_ = true_;\n/**\n * Encode the boolean false.\n */\nfunction false_() {\n    return raw(new Uint8Array([(7 /* SimpleValue */ << 5) + 20]));\n}\nexports.false_ = false_;\n/**\n * Encode the constant null.\n */\nfunction null_() {\n    return raw(new Uint8Array([(7 /* SimpleValue */ << 5) + 22]));\n}\nexports.null_ = null_;\n/**\n * Encode the constant undefined.\n */\nfunction undefined_() {\n    return raw(new Uint8Array([(7 /* SimpleValue */ << 5) + 23]));\n}\nexports.undefined_ = undefined_;\n//# sourceMappingURL=value.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL3NpbXBsZS1jYm9yL3NyYy92YWx1ZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvc2ltcGxlLWNib3Ivc3JjL3ZhbHVlLmpzPzg0YjMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBNQVhfVTY0X05VTUJFUiA9IDB4MjAwMDAwMDAwMDAwMDA7XG5mdW5jdGlvbiBfY29uY2F0KGEsIC4uLmFyZ3MpIHtcbiAgICBjb25zdCBuZXdCdWZmZXIgPSBuZXcgVWludDhBcnJheShhLmJ5dGVMZW5ndGggKyBhcmdzLnJlZHVjZSgoYWNjLCBiKSA9PiBhY2MgKyBiLmJ5dGVMZW5ndGgsIDApKTtcbiAgICBuZXdCdWZmZXIuc2V0KG5ldyBVaW50OEFycmF5KGEpLCAwKTtcbiAgICBsZXQgaSA9IGEuYnl0ZUxlbmd0aDtcbiAgICBmb3IgKGNvbnN0IGIgb2YgYXJncykge1xuICAgICAgICBuZXdCdWZmZXIuc2V0KG5ldyBVaW50OEFycmF5KGIpLCBpKTtcbiAgICAgICAgaSArPSBiLmJ5dGVMZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiBuZXdCdWZmZXIuYnVmZmVyO1xufVxuZnVuY3Rpb24gX3NlcmlhbGl6ZVZhbHVlKG1ham9yLCBtaW5vciwgdmFsdWUpIHtcbiAgICAvLyBSZW1vdmUgZXZlcnl0aGluZyB0aGF0J3Mgbm90IGFuIGhleGFkZWNpbWFsIGNoYXJhY3Rlci4gVGhlc2UgYXJlIG5vdFxuICAgIC8vIGNvbnNpZGVyZWQgZXJyb3JzIHNpbmNlIHRoZSB2YWx1ZSB3YXMgYWxyZWFkeSB2YWxpZGF0ZWQgYW5kIHRoZXkgbWlnaHRcbiAgICAvLyBiZSBudW1iZXIgZGVjaW1hbHMgb3Igc2lnbi5cbiAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1teMC05YS1mQS1GXS9nLCBcIlwiKTtcbiAgICAvLyBDcmVhdGUgdGhlIGJ1ZmZlciBmcm9tIHRoZSB2YWx1ZSB3aXRoIGxlZnQgcGFkZGluZyB3aXRoIDAuXG4gICAgY29uc3QgbGVuZ3RoID0gMiAqKiAobWlub3IgLSAyNCAvKiBJbnQ4ICovKTtcbiAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKC1sZW5ndGggKiAyKS5wYWRTdGFydChsZW5ndGggKiAyLCBcIjBcIik7XG4gICAgY29uc3QgYnl0ZXMgPSBbKG1ham9yIDw8IDUpICsgbWlub3JdLmNvbmNhdCh2YWx1ZS5tYXRjaCgvLi4vZykubWFwKChieXRlKSA9PiBwYXJzZUludChieXRlLCAxNikpKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMpLmJ1ZmZlcjtcbn1cbmZ1bmN0aW9uIF9zZXJpYWxpemVOdW1iZXIobWFqb3IsIHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlIDwgMjQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsobWFqb3IgPDwgNSkgKyB2YWx1ZV0pLmJ1ZmZlcjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IG1pbm9yID0gdmFsdWUgPD0gMHhmZlxuICAgICAgICAgICAgPyAyNCAvKiBJbnQ4ICovXG4gICAgICAgICAgICA6IHZhbHVlIDw9IDB4ZmZmZlxuICAgICAgICAgICAgICAgID8gMjUgLyogSW50MTYgKi9cbiAgICAgICAgICAgICAgICA6IHZhbHVlIDw9IDB4ZmZmZmZmZmZcbiAgICAgICAgICAgICAgICAgICAgPyAyNiAvKiBJbnQzMiAqL1xuICAgICAgICAgICAgICAgICAgICA6IDI3IC8qIEludDY0ICovO1xuICAgICAgICByZXR1cm4gX3NlcmlhbGl6ZVZhbHVlKG1ham9yLCBtaW5vciwgdmFsdWUudG9TdHJpbmcoMTYpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBfc2VyaWFsaXplU3RyaW5nKHN0cikge1xuICAgIGNvbnN0IHV0ZjggPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgY2hhcmNvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGNoYXJjb2RlIDwgMHg4MCkge1xuICAgICAgICAgICAgdXRmOC5wdXNoKGNoYXJjb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaGFyY29kZSA8IDB4ODAwKSB7XG4gICAgICAgICAgICB1dGY4LnB1c2goMHhjMCB8IChjaGFyY29kZSA+PiA2KSwgMHg4MCB8IChjaGFyY29kZSAmIDB4M2YpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaGFyY29kZSA8IDB4ZDgwMCB8fCBjaGFyY29kZSA+PSAweGUwMDApIHtcbiAgICAgICAgICAgIHV0ZjgucHVzaCgweGUwIHwgKGNoYXJjb2RlID4+IDEyKSwgMHg4MCB8ICgoY2hhcmNvZGUgPj4gNikgJiAweDNmKSwgMHg4MCB8IChjaGFyY29kZSAmIDB4M2YpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFN1cnJvZ2F0ZSBwYWlyXG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBjaGFyY29kZSA9ICgoY2hhcmNvZGUgJiAweDNmZikgPDwgMTApIHwgKHN0ci5jaGFyQ29kZUF0KGkpICYgMHgzZmYpO1xuICAgICAgICAgICAgdXRmOC5wdXNoKDB4ZjAgfCAoY2hhcmNvZGUgPj4gMTgpLCAweDgwIHwgKChjaGFyY29kZSA+PiAxMikgJiAweDNmKSwgMHg4MCB8ICgoY2hhcmNvZGUgPj4gNikgJiAweDNmKSwgMHg4MCB8IChjaGFyY29kZSAmIDB4M2YpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gX2NvbmNhdChuZXcgVWludDhBcnJheShfc2VyaWFsaXplTnVtYmVyKDMgLyogVGV4dFN0cmluZyAqLywgc3RyLmxlbmd0aCkpLCBuZXcgVWludDhBcnJheSh1dGY4KSk7XG59XG4vKipcbiAqIFRhZyBhIHZhbHVlLlxuICovXG5mdW5jdGlvbiB0YWdnZWQodGFnLCB2YWx1ZSkge1xuICAgIGlmICh0YWcgPT0gMHhkOWQ5ZjcpIHtcbiAgICAgICAgcmV0dXJuIF9jb25jYXQobmV3IFVpbnQ4QXJyYXkoWzB4ZDksIDB4ZDksIDB4ZjddKSwgdmFsdWUpO1xuICAgIH1cbiAgICBpZiAodGFnIDwgMjQpIHtcbiAgICAgICAgcmV0dXJuIF9jb25jYXQobmV3IFVpbnQ4QXJyYXkoWyg2IC8qIFRhZyAqLyA8PCA1KSArIHRhZ10pLCB2YWx1ZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBtaW5vciA9IHRhZyA8PSAweGZmXG4gICAgICAgICAgICA/IDI0IC8qIEludDggKi9cbiAgICAgICAgICAgIDogdGFnIDw9IDB4ZmZmZlxuICAgICAgICAgICAgICAgID8gMjUgLyogSW50MTYgKi9cbiAgICAgICAgICAgICAgICA6IHRhZyA8PSAweGZmZmZmZmZmXG4gICAgICAgICAgICAgICAgICAgID8gMjYgLyogSW50MzIgKi9cbiAgICAgICAgICAgICAgICAgICAgOiAyNyAvKiBJbnQ2NCAqLztcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gMiAqKiAobWlub3IgLSAyNCAvKiBJbnQ4ICovKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0YWdcbiAgICAgICAgICAgIC50b1N0cmluZygxNilcbiAgICAgICAgICAgIC5zbGljZSgtbGVuZ3RoICogMilcbiAgICAgICAgICAgIC5wYWRTdGFydChsZW5ndGggKiAyLCBcIjBcIik7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gWyg2IC8qIFRhZyAqLyA8PCA1KSArIG1pbm9yXS5jb25jYXQodmFsdWUubWF0Y2goLy4uL2cpLm1hcCgoYnl0ZSkgPT4gcGFyc2VJbnQoYnl0ZSwgMTYpKSk7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShieXRlcykuYnVmZmVyO1xuICAgIH1cbn1cbmV4cG9ydHMudGFnZ2VkID0gdGFnZ2VkO1xuLyoqXG4gKiBTZXQgdGhlIHJhdyBieXRlcyBjb250YWluZWQgYnkgdGhpcyB2YWx1ZS4gVGhpcyBzaG91bGQgb25seSBiZSB1c2VkIHdpdGggYW5vdGhlclxuICogQ2JvclZhbHVlLCBvciBpZiB5b3UgYXJlIGltcGxlbWVudGluZyBleHRlbnNpb25zIHRvIENCT1IuXG4gKiBAcGFyYW0gYnl0ZXMgQSBidWZmZXIgY29udGFpbmluZyB0aGUgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHJhdyhieXRlcykge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShieXRlcykuYnVmZmVyO1xufVxuZXhwb3J0cy5yYXcgPSByYXc7XG4vKipcbiAqIEVuY29kZSBhIG51bWJlciB0aGF0IGlzIGJldHdlZW4gWzAsIDIzXS5cbiAqIEBwYXJhbSBuXG4gKi9cbmZ1bmN0aW9uIHVTbWFsbChuKSB7XG4gICAgaWYgKGlzTmFOKG4pKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBudW1iZXIuXCIpO1xuICAgIH1cbiAgICBuID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgbiksIDIzKTsgLy8gQ2xhbXAgaXQuXG4gICAgY29uc3QgYnl0ZXMgPSBbKDAgLyogVW5zaWduZWRJbnRlZ2VyICovIDw8IDUpICsgbl07XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ5dGVzKS5idWZmZXI7XG59XG5leHBvcnRzLnVTbWFsbCA9IHVTbWFsbDtcbmZ1bmN0aW9uIHU4KHU4LCByYWRpeCkge1xuICAgIC8vIEZvcmNlIHU4IGludG8gYSBudW1iZXIsIGFuZCB2YWxpZGF0ZSBpdC5cbiAgICB1OCA9IHBhcnNlSW50KFwiXCIgKyB1OCwgcmFkaXgpO1xuICAgIGlmIChpc05hTih1OCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIG51bWJlci5cIik7XG4gICAgfVxuICAgIHU4ID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgdTgpLCAweGZmKTsgLy8gQ2xhbXAgaXQuXG4gICAgdTggPSB1OC50b1N0cmluZygxNik7XG4gICAgcmV0dXJuIF9zZXJpYWxpemVWYWx1ZSgwIC8qIFVuc2lnbmVkSW50ZWdlciAqLywgMjQgLyogSW50OCAqLywgdTgpO1xufVxuZXhwb3J0cy51OCA9IHU4O1xuZnVuY3Rpb24gdTE2KHUxNiwgcmFkaXgpIHtcbiAgICAvLyBGb3JjZSB1MTYgaW50byBhIG51bWJlciwgYW5kIHZhbGlkYXRlIGl0LlxuICAgIHUxNiA9IHBhcnNlSW50KFwiXCIgKyB1MTYsIHJhZGl4KTtcbiAgICBpZiAoaXNOYU4odTE2KSkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgbnVtYmVyLlwiKTtcbiAgICB9XG4gICAgdTE2ID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgdTE2KSwgMHhmZmZmKTsgLy8gQ2xhbXAgaXQuXG4gICAgdTE2ID0gdTE2LnRvU3RyaW5nKDE2KTtcbiAgICByZXR1cm4gX3NlcmlhbGl6ZVZhbHVlKDAgLyogVW5zaWduZWRJbnRlZ2VyICovLCAyNSAvKiBJbnQxNiAqLywgdTE2KTtcbn1cbmV4cG9ydHMudTE2ID0gdTE2O1xuZnVuY3Rpb24gdTMyKHUzMiwgcmFkaXgpIHtcbiAgICAvLyBGb3JjZSB1MzIgaW50byBhIG51bWJlciwgYW5kIHZhbGlkYXRlIGl0LlxuICAgIHUzMiA9IHBhcnNlSW50KFwiXCIgKyB1MzIsIHJhZGl4KTtcbiAgICBpZiAoaXNOYU4odTMyKSkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgbnVtYmVyLlwiKTtcbiAgICB9XG4gICAgdTMyID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgdTMyKSwgMHhmZmZmZmZmZik7IC8vIENsYW1wIGl0LlxuICAgIHUzMiA9IHUzMi50b1N0cmluZygxNik7XG4gICAgcmV0dXJuIF9zZXJpYWxpemVWYWx1ZSgwIC8qIFVuc2lnbmVkSW50ZWdlciAqLywgMjYgLyogSW50MzIgKi8sIHUzMik7XG59XG5leHBvcnRzLnUzMiA9IHUzMjtcbmZ1bmN0aW9uIHU2NCh1NjQsIHJhZGl4KSB7XG4gICAgLy8gU3BlY2lhbCBjb25zaWRlcmF0aW9uIGZvciBudW1iZXJzIHRoYXQgbWlnaHQgYmUgbGFyZ2VyIHRoYW4gZXhwZWN0ZWQuXG4gICAgaWYgKHR5cGVvZiB1NjQgPT0gXCJzdHJpbmdcIiAmJiByYWRpeCA9PSAxNikge1xuICAgICAgICAvLyBUaGlzIGlzIHRoZSBvbmx5IGNhc2Ugd2hlcmUgd2UgZ3VhcmFudGVlIHdlJ2xsIGVuY29kZSB0aGUgbnVtYmVyIGRpcmVjdGx5LlxuICAgICAgICAvLyBWYWxpZGF0ZSBpdCdzIGFsbCBoZXhhZGVjaW1hbCBmaXJzdC5cbiAgICAgICAgaWYgKHU2NC5tYXRjaCgvW14wLTlhLWZBLUZdLykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBudW1iZXIuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfc2VyaWFsaXplVmFsdWUoMCAvKiBVbnNpZ25lZEludGVnZXIgKi8sIDI3IC8qIEludDY0ICovLCB1NjQpO1xuICAgIH1cbiAgICAvLyBGb3JjZSB1NjQgaW50byBhIG51bWJlciwgYW5kIHZhbGlkYXRlIGl0LlxuICAgIHU2NCA9IHBhcnNlSW50KFwiXCIgKyB1NjQsIHJhZGl4KTtcbiAgICBpZiAoaXNOYU4odTY0KSkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgbnVtYmVyLlwiKTtcbiAgICB9XG4gICAgdTY0ID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgdTY0KSwgTUFYX1U2NF9OVU1CRVIpOyAvLyBDbGFtcCBpdCB0byBhY3R1YWwgbGltaXQuXG4gICAgdTY0ID0gdTY0LnRvU3RyaW5nKDE2KTtcbiAgICByZXR1cm4gX3NlcmlhbGl6ZVZhbHVlKDAgLyogVW5zaWduZWRJbnRlZ2VyICovLCAyNyAvKiBJbnQ2NCAqLywgdTY0KTtcbn1cbmV4cG9ydHMudTY0ID0gdTY0O1xuLyoqXG4gKiBFbmNvZGUgYSBuZWdhdGl2ZSBudW1iZXIgdGhhdCBpcyBiZXR3ZWVuIFstMjQsIC0xXS5cbiAqL1xuZnVuY3Rpb24gaVNtYWxsKG4pIHtcbiAgICBpZiAoaXNOYU4obikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIG51bWJlci5cIik7XG4gICAgfVxuICAgIGlmIChuID09PSAwKSB7XG4gICAgICAgIHJldHVybiB1U21hbGwoMCk7XG4gICAgfVxuICAgIC8vIE5lZ2F0aXZlIG4sIGNsYW1wZWQgdG8gWzEsIDI0XSwgbWludXMgMSAodGhlcmUncyBubyBuZWdhdGl2ZSAwKS5cbiAgICBuID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgLW4pLCAyNCkgLSAxO1xuICAgIGNvbnN0IGJ5dGVzID0gWygxIC8qIFNpZ25lZEludGVnZXIgKi8gPDwgNSkgKyBuXTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMpLmJ1ZmZlcjtcbn1cbmV4cG9ydHMuaVNtYWxsID0gaVNtYWxsO1xuZnVuY3Rpb24gaTgoaTgsIHJhZGl4KSB7XG4gICAgLy8gRm9yY2UgaTggaW50byBhIG51bWJlciwgYW5kIHZhbGlkYXRlIGl0LlxuICAgIGk4ID0gcGFyc2VJbnQoXCJcIiArIGk4LCByYWRpeCk7XG4gICAgaWYgKGlzTmFOKGk4KSkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgbnVtYmVyLlwiKTtcbiAgICB9XG4gICAgLy8gTmVnYXRpdmUgbiwgY2xhbXBlZCwgbWludXMgMSAodGhlcmUncyBubyBuZWdhdGl2ZSAwKS5cbiAgICBpOCA9IE1hdGgubWluKE1hdGgubWF4KDAsIC1pOCAtIDEpLCAweGZmKTtcbiAgICBpOCA9IGk4LnRvU3RyaW5nKDE2KTtcbiAgICByZXR1cm4gX3NlcmlhbGl6ZVZhbHVlKDEgLyogU2lnbmVkSW50ZWdlciAqLywgMjQgLyogSW50OCAqLywgaTgpO1xufVxuZXhwb3J0cy5pOCA9IGk4O1xuZnVuY3Rpb24gaTE2KGkxNiwgcmFkaXgpIHtcbiAgICAvLyBGb3JjZSBpMTYgaW50byBhIG51bWJlciwgYW5kIHZhbGlkYXRlIGl0LlxuICAgIGkxNiA9IHBhcnNlSW50KFwiXCIgKyBpMTYsIHJhZGl4KTtcbiAgICBpZiAoaXNOYU4oaTE2KSkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgbnVtYmVyLlwiKTtcbiAgICB9XG4gICAgLy8gTmVnYXRpdmUgbiwgY2xhbXBlZCwgbWludXMgMSAodGhlcmUncyBubyBuZWdhdGl2ZSAwKS5cbiAgICBpMTYgPSBNYXRoLm1pbihNYXRoLm1heCgwLCAtaTE2IC0gMSksIDB4ZmZmZik7XG4gICAgaTE2ID0gaTE2LnRvU3RyaW5nKDE2KTtcbiAgICByZXR1cm4gX3NlcmlhbGl6ZVZhbHVlKDEgLyogU2lnbmVkSW50ZWdlciAqLywgMjUgLyogSW50MTYgKi8sIGkxNik7XG59XG5leHBvcnRzLmkxNiA9IGkxNjtcbmZ1bmN0aW9uIGkzMihpMzIsIHJhZGl4KSB7XG4gICAgLy8gRm9yY2UgaTMyIGludG8gYSBudW1iZXIsIGFuZCB2YWxpZGF0ZSBpdC5cbiAgICBpMzIgPSBwYXJzZUludChcIlwiICsgaTMyLCByYWRpeCk7XG4gICAgaWYgKGlzTmFOKGkzMikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIG51bWJlci5cIik7XG4gICAgfVxuICAgIC8vIE5lZ2F0aXZlIG4sIGNsYW1wZWQsIG1pbnVzIDEgKHRoZXJlJ3Mgbm8gbmVnYXRpdmUgMCkuXG4gICAgaTMyID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgLWkzMiAtIDEpLCAweGZmZmZmZmZmKTtcbiAgICBpMzIgPSBpMzIudG9TdHJpbmcoMTYpO1xuICAgIHJldHVybiBfc2VyaWFsaXplVmFsdWUoMSAvKiBTaWduZWRJbnRlZ2VyICovLCAyNiAvKiBJbnQzMiAqLywgaTMyKTtcbn1cbmV4cG9ydHMuaTMyID0gaTMyO1xuZnVuY3Rpb24gaTY0KGk2NCwgcmFkaXgpIHtcbiAgICAvLyBTcGVjaWFsIGNvbnNpZGVyYXRpb24gZm9yIG51bWJlcnMgdGhhdCBtaWdodCBiZSBsYXJnZXIgdGhhbiBleHBlY3RlZC5cbiAgICBpZiAodHlwZW9mIGk2NCA9PSBcInN0cmluZ1wiICYmIHJhZGl4ID09IDE2KSB7XG4gICAgICAgIGlmIChpNjQuc3RhcnRzV2l0aChcIi1cIikpIHtcbiAgICAgICAgICAgIGk2NCA9IGk2NC5zbGljZSgxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIENsYW1wIGl0LlxuICAgICAgICAgICAgaTY0ID0gXCIwXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhpcyBpcyB0aGUgb25seSBjYXNlIHdoZXJlIHdlIGd1YXJhbnRlZSB3ZSdsbCBlbmNvZGUgdGhlIG51bWJlciBkaXJlY3RseS5cbiAgICAgICAgLy8gVmFsaWRhdGUgaXQncyBhbGwgaGV4YWRlY2ltYWwgZmlyc3QuXG4gICAgICAgIGlmIChpNjQubWF0Y2goL1teMC05YS1mQS1GXS8pIHx8IGk2NC5sZW5ndGggPiAxNikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIG51bWJlci5cIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UgbmVlZCB0byBkbyAtMSB0byB0aGUgbnVtYmVyLlxuICAgICAgICBsZXQgZG9uZSA9IGZhbHNlO1xuICAgICAgICBsZXQgbmV3STY0ID0gaTY0LnNwbGl0KFwiXCIpLnJlZHVjZVJpZ2h0KChhY2MsIHgpID0+IHtcbiAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHggKyBhY2M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbiA9IHBhcnNlSW50KHgsIDE2KSAtIDE7XG4gICAgICAgICAgICBpZiAobiA+PSAwKSB7XG4gICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG4udG9TdHJpbmcoMTYpICsgYWNjO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiZlwiICsgYWNjO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBcIlwiKTtcbiAgICAgICAgaWYgKCFkb25lKSB7XG4gICAgICAgICAgICAvLyBUaGlzIG51bWJlciB3YXMgMC5cbiAgICAgICAgICAgIHJldHVybiB1NjQoMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9zZXJpYWxpemVWYWx1ZSgxIC8qIFNpZ25lZEludGVnZXIgKi8sIDI3IC8qIEludDY0ICovLCBuZXdJNjQpO1xuICAgIH1cbiAgICAvLyBGb3JjZSBpNjQgaW50byBhIG51bWJlciwgYW5kIHZhbGlkYXRlIGl0LlxuICAgIGk2NCA9IHBhcnNlSW50KFwiXCIgKyBpNjQsIHJhZGl4KTtcbiAgICBpZiAoaXNOYU4oaTY0KSkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgbnVtYmVyLlwiKTtcbiAgICB9XG4gICAgaTY0ID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgLWk2NCAtIDEpLCAweDIwMDAwMDAwMDAwMDAwKTsgLy8gQ2xhbXAgaXQgdG8gYWN0dWFsLlxuICAgIGk2NCA9IGk2NC50b1N0cmluZygxNik7XG4gICAgcmV0dXJuIF9zZXJpYWxpemVWYWx1ZSgxIC8qIFNpZ25lZEludGVnZXIgKi8sIDI3IC8qIEludDY0ICovLCBpNjQpO1xufVxuZXhwb3J0cy5pNjQgPSBpNjQ7XG4vKipcbiAqIEVuY29kZSBhIG51bWJlciB1c2luZyB0aGUgc21hbGxlc3QgYW1vdW50IG9mIGJ5dGVzLCBieSBjYWxsaW5nIHRoZSBtZXRob2RzXG4gKiBhYm92ZS4gZS5nLiBJZiB0aGUgbnVtYmVyIGZpdHMgaW4gYSB1OCwgaXQgd2lsbCB1c2UgdGhhdC5cbiAqL1xuZnVuY3Rpb24gbnVtYmVyKG4pIHtcbiAgICBpZiAobiA+PSAwKSB7XG4gICAgICAgIGlmIChuIDwgMjQpIHtcbiAgICAgICAgICAgIHJldHVybiB1U21hbGwobik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobiA8PSAweGZmKSB7XG4gICAgICAgICAgICByZXR1cm4gdTgobik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobiA8PSAweGZmZmYpIHtcbiAgICAgICAgICAgIHJldHVybiB1MTYobik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobiA8PSAweGZmZmZmZmZmKSB7XG4gICAgICAgICAgICByZXR1cm4gdTMyKG4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHU2NChuKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKG4gPj0gLTI0KSB7XG4gICAgICAgICAgICByZXR1cm4gaVNtYWxsKG4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG4gPj0gLTB4ZmYpIHtcbiAgICAgICAgICAgIHJldHVybiBpOChuKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuID49IC0weGZmZmYpIHtcbiAgICAgICAgICAgIHJldHVybiBpMTYobik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobiA+PSAtMHhmZmZmZmZmZikge1xuICAgICAgICAgICAgcmV0dXJuIGkzMihuKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBpNjQobik7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLm51bWJlciA9IG51bWJlcjtcbi8qKlxuICogRW5jb2RlIGEgYnl0ZSBhcnJheS4gVGhpcyBpcyBkaWZmZXJlbnQgdGhhbiB0aGUgYHJhdygpYCBtZXRob2QuXG4gKi9cbmZ1bmN0aW9uIGJ5dGVzKGJ5dGVzKSB7XG4gICAgcmV0dXJuIF9jb25jYXQoX3NlcmlhbGl6ZU51bWJlcigyIC8qIEJ5dGVTdHJpbmcgKi8sIGJ5dGVzLmJ5dGVMZW5ndGgpLCBieXRlcyk7XG59XG5leHBvcnRzLmJ5dGVzID0gYnl0ZXM7XG4vKipcbiAqIEVuY29kZSBhIEphdmFTY3JpcHQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBzdHJpbmcoc3RyKSB7XG4gICAgcmV0dXJuIF9zZXJpYWxpemVTdHJpbmcoc3RyKTtcbn1cbmV4cG9ydHMuc3RyaW5nID0gc3RyaW5nO1xuLyoqXG4gKiBFbmNvZGUgYW4gYXJyYXkgb2YgY2JvciB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIGFycmF5KGl0ZW1zKSB7XG4gICAgcmV0dXJuIF9jb25jYXQoX3NlcmlhbGl6ZU51bWJlcig0IC8qIEFycmF5ICovLCBpdGVtcy5sZW5ndGgpLCAuLi5pdGVtcyk7XG59XG5leHBvcnRzLmFycmF5ID0gYXJyYXk7XG4vKipcbiAqIEVuY29kZSBhIG1hcCBvZiBrZXktdmFsdWUgcGFpcnMuIFRoZSBrZXlzIGFyZSBzdHJpbmcsIGFuZCB0aGUgdmFsdWVzIGFyZSBDQk9SXG4gKiBlbmNvZGVkLlxuICovXG5mdW5jdGlvbiBtYXAoaXRlbXMsIHN0YWJsZSA9IGZhbHNlKSB7XG4gICAgaWYgKCEoaXRlbXMgaW5zdGFuY2VvZiBNYXApKSB7XG4gICAgICAgIGl0ZW1zID0gbmV3IE1hcChPYmplY3QuZW50cmllcyhpdGVtcykpO1xuICAgIH1cbiAgICBsZXQgZW50cmllcyA9IEFycmF5LmZyb20oaXRlbXMuZW50cmllcygpKTtcbiAgICBpZiAoc3RhYmxlKSB7XG4gICAgICAgIGVudHJpZXMgPSBlbnRyaWVzLnNvcnQoKFtrZXlBXSwgW2tleUJdKSA9PiBrZXlBLmxvY2FsZUNvbXBhcmUoa2V5QikpO1xuICAgIH1cbiAgICByZXR1cm4gX2NvbmNhdChfc2VyaWFsaXplTnVtYmVyKDUgLyogTWFwICovLCBpdGVtcy5zaXplKSwgLi4uZW50cmllcy5tYXAoKFtrLCB2XSkgPT4gX2NvbmNhdChfc2VyaWFsaXplU3RyaW5nKGspLCB2KSkpO1xufVxuZXhwb3J0cy5tYXAgPSBtYXA7XG4vKipcbiAqIEVuY29kZSBhIHNpbmdsZSAoMzIgYml0cykgcHJlY2lzaW9uIGZsb2F0aW5nIHBvaW50IG51bWJlci5cbiAqL1xuZnVuY3Rpb24gc2luZ2xlRmxvYXQoZikge1xuICAgIGNvbnN0IHNpbmdsZSA9IG5ldyBGbG9hdDMyQXJyYXkoW2ZdKTtcbiAgICByZXR1cm4gX2NvbmNhdChuZXcgVWludDhBcnJheShbKDcgLyogU2ltcGxlVmFsdWUgKi8gPDwgNSkgKyAyNl0pLCBuZXcgVWludDhBcnJheShzaW5nbGUuYnVmZmVyKSk7XG59XG5leHBvcnRzLnNpbmdsZUZsb2F0ID0gc2luZ2xlRmxvYXQ7XG4vKipcbiAqIEVuY29kZSBhIGRvdWJsZSAoNjQgYml0cykgcHJlY2lzaW9uIGZsb2F0aW5nIHBvaW50IG51bWJlci5cbiAqL1xuZnVuY3Rpb24gZG91YmxlRmxvYXQoZikge1xuICAgIGNvbnN0IHNpbmdsZSA9IG5ldyBGbG9hdDY0QXJyYXkoW2ZdKTtcbiAgICByZXR1cm4gX2NvbmNhdChuZXcgVWludDhBcnJheShbKDcgLyogU2ltcGxlVmFsdWUgKi8gPDwgNSkgKyAyN10pLCBuZXcgVWludDhBcnJheShzaW5nbGUuYnVmZmVyKSk7XG59XG5leHBvcnRzLmRvdWJsZUZsb2F0ID0gZG91YmxlRmxvYXQ7XG5mdW5jdGlvbiBib29sKHYpIHtcbiAgICByZXR1cm4gdiA/IHRydWVfKCkgOiBmYWxzZV8oKTtcbn1cbmV4cG9ydHMuYm9vbCA9IGJvb2w7XG4vKipcbiAqIEVuY29kZSB0aGUgYm9vbGVhbiB0cnVlLlxuICovXG5mdW5jdGlvbiB0cnVlXygpIHtcbiAgICByZXR1cm4gcmF3KG5ldyBVaW50OEFycmF5KFsoNyAvKiBTaW1wbGVWYWx1ZSAqLyA8PCA1KSArIDIxXSkpO1xufVxuZXhwb3J0cy50cnVlXyA9IHRydWVfO1xuLyoqXG4gKiBFbmNvZGUgdGhlIGJvb2xlYW4gZmFsc2UuXG4gKi9cbmZ1bmN0aW9uIGZhbHNlXygpIHtcbiAgICByZXR1cm4gcmF3KG5ldyBVaW50OEFycmF5KFsoNyAvKiBTaW1wbGVWYWx1ZSAqLyA8PCA1KSArIDIwXSkpO1xufVxuZXhwb3J0cy5mYWxzZV8gPSBmYWxzZV87XG4vKipcbiAqIEVuY29kZSB0aGUgY29uc3RhbnQgbnVsbC5cbiAqL1xuZnVuY3Rpb24gbnVsbF8oKSB7XG4gICAgcmV0dXJuIHJhdyhuZXcgVWludDhBcnJheShbKDcgLyogU2ltcGxlVmFsdWUgKi8gPDwgNSkgKyAyMl0pKTtcbn1cbmV4cG9ydHMubnVsbF8gPSBudWxsXztcbi8qKlxuICogRW5jb2RlIHRoZSBjb25zdGFudCB1bmRlZmluZWQuXG4gKi9cbmZ1bmN0aW9uIHVuZGVmaW5lZF8oKSB7XG4gICAgcmV0dXJuIHJhdyhuZXcgVWludDhBcnJheShbKDcgLyogU2ltcGxlVmFsdWUgKi8gPDwgNSkgKyAyM10pKTtcbn1cbmV4cG9ydHMudW5kZWZpbmVkXyA9IHVuZGVmaW5lZF87XG4vLyMgc291cmNlTWFwcGluZ1VSTD12YWx1ZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/simple-cbor/src/value.js\n");

/***/ })

};
;